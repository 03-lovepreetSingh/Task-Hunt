import * as React from 'react';
import { Trim } from './fileRoute.cjs';
import { AnyRoute, ReactNode, RootSearchSchema } from './route.cjs';
import { RouteByPath, RoutePaths } from './routeInfo.cjs';
import { RegisteredRouter } from './router.cjs';
import { LinkProps, UseLinkPropsOptions } from './useNavigate.cjs';
import { Expand, IsUnion, MakeDifferenceOptional, NoInfer, NonNullableUpdater, PickRequired, StringLiteral, Updater, WithoutEmpty } from './utils.cjs';
import { HistoryState } from '@tanstack/history';
export type CleanPath<T extends string> = T extends `${infer L}//${infer R}` ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`> : T extends `${infer L}//` ? `${CleanPath<L>}/` : T extends `//${infer L}` ? `/${CleanPath<L>}` : T;
export type Split<S, TIncludeTrailingSlash = true> = S extends unknown ? string extends S ? string[] : S extends string ? CleanPath<S> extends '' ? [] : TIncludeTrailingSlash extends true ? CleanPath<S> extends `${infer T}/` ? [...Split<T>, '/'] : CleanPath<S> extends `/${infer U}` ? Split<U> : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : [S] : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : S extends string ? [S] : never : never : never;
export type ParsePathParams<T extends string> = keyof {
    [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L extends '' ? '_splat' : L : never]: K;
};
export type Join<T, Delimiter extends string = '/'> = T extends [] ? '' : T extends [infer L extends string] ? L : T extends [infer L extends string, ...infer Tail extends [...string[]]] ? CleanPath<`${L}${Delimiter}${Join<Tail>}`> : never;
export type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;
export type RelativeToPathAutoComplete<AllPaths extends string, TFrom extends string, TTo extends string, SplitPaths extends string[] = Split<AllPaths, false>> = TTo extends `..${infer _}` ? SplitPaths extends [
    ...Split<ResolveRelativePath<TFrom, TTo>, false>,
    ...infer TToRest
] ? `${CleanPath<Join<[
    ...Split<TTo, false>,
    ...(TToRest | (Split<ResolveRelativePath<TFrom, TTo>, false>['length'] extends 1 ? never : ['../']))
]>>}` : never : TTo extends `./${infer RestTTo}` ? SplitPaths extends [
    ...Split<TFrom, false>,
    ...Split<RestTTo, false>,
    ...infer RestPath
] ? `${TTo}${Join<RestPath>}` : never : (TFrom extends `/` ? never : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath] ? Join<RestPath> extends {
    length: 0;
} ? never : './' : never) | (TFrom extends `/` ? never : '../') | AllPaths;
export type NavigateOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = RoutePaths<TRouteTree>, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    replace?: boolean;
    resetScroll?: boolean;
    startTransition?: boolean;
};
export type ToOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = RoutePaths<TRouteTree>, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = ToSubOptions<TRouteTree, TFrom, TTo> & {
    mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>;
};
export type ToMaskOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TMaskFrom extends RoutePaths<TRouteTree> | string = RoutePaths<TRouteTree>, TMaskTo extends string = ''> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {
    unmaskOnReload?: boolean;
};
export type ToSubOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = RoutePaths<TRouteTree>, TTo extends string = '', TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>> = {
    to?: ToPathOption<TRouteTree, TFrom, TTo>;
    hash?: true | Updater<string>;
    state?: true | NonNullableUpdater<HistoryState>;
    from?: StringLiteral<TFrom>;
} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> & SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> & PathParamOptions<TRouteTree, TFrom, TTo, TResolved>;
type ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo);
type ParamVariant = 'PATH' | 'SEARCH';
type ExcludeRootSearchSchema<T, Excluded = Exclude<T, RootSearchSchema>> = [
    Excluded
] extends [never] ? {} : Excluded;
type PostProcessParams<T, TParamVariant extends ParamVariant> = TParamVariant extends 'SEARCH' ? ExcludeRootSearchSchema<T> : T;
export type ParamOptions<TRouteTree extends AnyRoute, TFrom, TTo extends string, TResolved, TParamVariant extends ParamVariant, TFromRouteType extends 'allParams' | 'fullSearchSchema' = TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchema', TToRouteType extends 'allParams' | 'fullSearchSchemaInput' = TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchemaInput', TFromParams = PostProcessParams<RouteByPath<TRouteTree, TFrom>['types'][TFromRouteType], TParamVariant>, TToIndex = TTo extends '' ? '' : RouteByPath<TRouteTree, `${TTo}/`> extends never ? TTo : `${TTo}/`, TToParams = TToIndex extends '' ? PostProcessParams<RouteByPath<TRouteTree, TFrom>['types'][TToRouteType], TParamVariant> : [TResolved] extends [never] ? PostProcessParams<RouteByPath<TRouteTree, TToIndex>['types'][TToRouteType], TParamVariant> : PostProcessParams<RouteByPath<TRouteTree, TResolved>['types'][TToRouteType], TParamVariant>, TRelativeToParams = TParamVariant extends 'SEARCH' ? TToParams : true extends IsUnion<TFromParams> ? TToParams : MakeDifferenceOptional<TFromParams, TToParams>, TReducer = ParamsReducer<TFromParams, TRelativeToParams>> = Expand<WithoutEmpty<PickRequired<TRelativeToParams>>> extends never ? Partial<MakeParamOption<TParamVariant, true | TReducer>> : TFromParams extends Expand<WithoutEmpty<PickRequired<TRelativeToParams>>> ? MakeParamOption<TParamVariant, true | TReducer> : MakeParamOption<TParamVariant, TReducer>;
type MakeParamOption<TParamVariant extends ParamVariant, T> = TParamVariant extends 'PATH' ? MakePathParamOptions<T> : MakeSearchParamOptions<T>;
type MakeSearchParamOptions<T> = {
    search: T;
};
type MakePathParamOptions<T> = {
    params: T;
};
export type SearchParamOptions<TRouteTree extends AnyRoute, TFrom, TTo extends string, TResolved> = ParamOptions<TRouteTree, TFrom, TTo, TResolved, 'SEARCH'>;
export type PathParamOptions<TRouteTree extends AnyRoute, TFrom, TTo extends string, TResolved> = ParamOptions<TRouteTree, TFrom, TTo, TResolved, 'PATH'>;
export type ToPathOption<TRouteTree extends AnyRoute = AnyRoute, TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = ''> = TTo | RelativeToPathAutoComplete<RoutePaths<TRouteTree>, NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
export interface ActiveOptions {
    exact?: boolean;
    includeHash?: boolean;
    includeSearch?: boolean;
}
export type LinkOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    target?: HTMLAnchorElement['target'];
    activeOptions?: ActiveOptions;
    preload?: false | 'intent';
    preloadDelay?: number;
    disabled?: boolean;
};
export type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<TPath, RoutePaths<TRouteTree>> extends never ? TPass : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>;
export type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {
    to: RoutePaths<TRouteTree>;
};
export type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string ? TTo extends string ? TTo extends '.' ? TFrom : TTo extends `./` ? Join<[TFrom, '/']> : TTo extends `./${infer TRest}` ? ResolveRelativePath<TFrom, TRest> : TTo extends `/${infer TRest}` ? TTo : Split<TTo> extends ['..', ...infer ToRest] ? Split<TFrom> extends [...infer FromRest, infer FromTail] ? ToRest extends ['/'] ? Join<[...FromRest, '/']> : ResolveRelativePath<Join<FromRest>, Join<ToRest>> : never : Split<TTo> extends ['.', ...infer ToRest] ? ToRest extends ['/'] ? Join<[TFrom, '/']> : ResolveRelativePath<TFrom, Join<ToRest>> : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>> : never : never;
export declare function useLinkProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''>(options: UseLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): React.AnchorHTMLAttributes<HTMLAnchorElement>;
export interface LinkComponent<TProps extends Record<string, any> = {}> {
    <TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> | string = string, TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom, TMaskTo extends string = ''>(props: LinkProps<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & TProps & React.RefAttributes<HTMLAnchorElement>): ReactNode;
}
export declare const Link: LinkComponent;
export {};
