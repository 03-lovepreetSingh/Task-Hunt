{"version":3,"file":"Matches.cjs","sources":["../../src/Matches.tsx"],"sourcesContent":["import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { ResolveRelativePath, ToOptions } from './link'\nimport {\n  AnyRoute,\n  ReactNode,\n  RootSearchSchema,\n  StaticDataRouteOption,\n  UpdatableStaticRouteOption,\n  rootRouteId,\n} from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter, RouterState } from './router'\nimport { DeepPartial, Expand, NoInfer, StrictOrFrom, pick } from './utils'\nimport {\n  CatchNotFound,\n  DefaultGlobalNotFound,\n  NotFoundError,\n  isNotFound,\n} from './not-found'\n\nexport const matchContext = React.createContext<string | undefined>(undefined)\n\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: TReturnIntersection extends false\n    ? RouteById<TRouteTree, TRouteId>['types']['allParams']\n    : Expand<Partial<AllParams<TRouteTree>>>\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  showPending: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData']\n  routeContext: RouteById<TRouteTree, TRouteId>['types']['routeContext']\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  search: TReturnIntersection extends false\n    ? Exclude<\n        RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema'],\n        RootSearchSchema\n      >\n    : Expand<\n        Partial<Omit<FullSearchSchema<TRouteTree>, keyof RootSearchSchema>>\n      >\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: RouteById<TRouteTree, TRouteId>['types']['loaderDeps']\n  preload: boolean\n  invalid: boolean\n  pendingPromise?: Promise<void>\n  meta?: JSX.IntrinsicElements['meta'][]\n  links?: JSX.IntrinsicElements['link'][]\n  scripts?: JSX.IntrinsicElements['script'][]\n  headers?: Record<string, string>\n  notFoundError?: NotFoundError\n  staticData: StaticDataRouteOption\n}\n\nexport type AnyRouteMatch = RouteMatch<any, any>\n\nexport function Matches() {\n  const router = useRouter()\n  const matchId = useRouterState({\n    select: (s) => {\n      return getRenderedMatches(s)[0]?.id\n    },\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => router.state.resolvedLocation.state?.key!}\n        errorComponent={ErrorComponent}\n        onCatch={(error) => {\n          warning(\n            false,\n            `The following error wasn't caught by any route! ðŸ‘‡ At the very least, consider setting an 'errorComponent' in your RootRoute!`,\n          )\n          console.error(error)\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matchId }: { matchId: string }) {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${matchId}\". Please file an issue!`,\n  )\n\n  const route = router.routesById[routeId]!\n\n  const PendingComponent = (route.options.pendingComponent ??\n    router.options.defaultPendingComponent) as any\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ??\n    router.options.defaultErrorComponent ??\n    ErrorComponent\n\n  const routeNotFoundComponent = route.isRoot\n    ? // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n      route.options.notFoundComponent ??\n      router.options.notFoundRoute?.options.component\n    : route.options.notFoundComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ??\n    PendingComponent ??\n    route.options.component?.preload ??\n    route.options.pendingComponent?.preload ??\n    (route.options.errorComponent as any)?.preload\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  const ResolvedNotFoundBoundary = routeNotFoundComponent\n    ? CatchNotFound\n    : SafeFragment\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <ResolvedSuspenseBoundary fallback={pendingElement}>\n        <ResolvedCatchBoundary\n          getResetKey={() => router.state.resolvedLocation.state?.key!}\n          errorComponent={routeErrorComponent}\n          onCatch={(error) => {\n            // Forward not found errors (we don't want to show the error component for these)\n            if (isNotFound(error)) throw error\n            warning(false, `Error in route match: ${matchId}`)\n            console.error(error)\n          }}\n        >\n          <ResolvedNotFoundBoundary\n            fallback={(error) => {\n              // If the current not found handler doesn't exist or doesn't handle global not founds, forward it up the tree\n              if (!routeNotFoundComponent || (error.global && !route.isRoot))\n                throw error\n\n              return React.createElement(routeNotFoundComponent, {\n                data: error.data,\n              })\n            }}\n          >\n            <MatchInner matchId={matchId!} pendingElement={pendingElement} />\n          </ResolvedNotFoundBoundary>\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction MatchInner({\n  matchId,\n  pendingElement,\n}: {\n  matchId: string\n  pendingElement: any\n}): any {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const match = useRouterState({\n    select: (s) =>\n      pick(getRenderedMatches(s).find((d) => d.id === matchId)!, [\n        'status',\n        'error',\n        'showPending',\n        'loadPromise',\n        'notFoundError',\n      ]),\n  })\n\n  // If a global not-found is found, and it's the root route, render the global not-found component.\n  if (match.notFoundError) {\n    if (routeId === rootRouteId && !route.options.notFoundComponent)\n      return <DefaultGlobalNotFound />\n\n    invariant(\n      route.options.notFoundComponent,\n      'Route matched with notFoundError should have a notFoundComponent',\n    )\n\n    return <route.options.notFoundComponent data={match.notFoundError} />\n  }\n\n  if (match.status === 'error') {\n    if (isServerSideError(match.error)) {\n      const deserializeError =\n        router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n      throw deserializeError(match.error.data)\n    } else {\n      throw match.error\n    }\n  }\n\n  if (match.status === 'pending') {\n    if (match.showPending) {\n      return pendingElement\n    }\n    throw match.loadPromise\n  }\n\n  if (match.status === 'success') {\n    let Comp = route.options.component ?? router.options.defaultComponent\n\n    if (Comp) {\n      return <Comp />\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport const Outlet = React.memo(function Outlet() {\n  const matchId = React.useContext(matchContext)\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = getRenderedMatches(s)\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  if (!childMatchId) {\n    return null\n  }\n\n  return <Match matchId={childMatchId} />\n})\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type UseMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n  Options extends ToOptions<\n    TRouteTree,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  > = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n  RelaxedOptions = Omit<Options, 'search' | 'params'> &\n    DeepPartial<Pick<Options, 'search' | 'params'>>,\n> = RelaxedOptions & MatchRouteOptions\n\nexport function useMatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>() {\n  useRouterState({ select: (s) => [s.location, s.resolvedLocation] })\n  const { matchRoute } = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n\n      return matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch,\n      })\n    },\n    [],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | ((\n        params?: RouteByPath<\n          TRouteTree,\n          ResolveRelativePath<TFrom, NoInfer<TTo>>\n        >['types']['allParams'],\n      ) => ReactNode)\n    | React.ReactNode\n}\n\nexport function MatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = RoutePaths<TRouteTree>,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return !!params ? props.children : null\n}\n\nexport function getRenderedMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(state: RouterState<TRouteTree>) {\n  return state.pendingMatches?.some((d) => d.showPending)\n    ? state.pendingMatches\n    : state.matches\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TReturnIntersection extends boolean = false,\n  TRouteMatchState = RouteMatch<TRouteTree, TFrom, TReturnIntersection>,\n  TSelected = TRouteMatchState,\n>(\n  opts: StrictOrFrom<TFrom, TReturnIntersection> & {\n    select?: (match: TRouteMatchState) => TSelected\n  },\n): TSelected {\n  const router = useRouter()\n  const nearestMatchId = React.useContext(matchContext)\n\n  const nearestMatchRouteId = getRenderedMatches(router.state).find(\n    (d) => d.id === nearestMatchId,\n  )?.routeId\n\n  const matchRouteId = (() => {\n    const matches = getRenderedMatches(router.state)\n    const match = opts?.from\n      ? matches.find((d) => d.routeId === opts?.from)\n      : matches.find((d) => d.id === nearestMatchId)\n    return match!.routeId\n  })()\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatchRouteId == matchRouteId,\n      `useMatch(\"${\n        matchRouteId as string\n      }\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${\n        matchRouteId as string\n      }\", { strict: false })' or 'useRoute(\"${\n        matchRouteId as string\n      }\")' instead?`,\n    )\n  }\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = getRenderedMatches(state).find(\n        (d) => d.id === nearestMatchId,\n      )\n\n      invariant(\n        match,\n        `Could not find ${\n          opts?.from\n            ? `an active match from \"${opts.from}\"`\n            : 'a nearest match!'\n        }`,\n      )\n\n      return opts?.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as any\n}\n\nexport function useMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = TRouteMatch[],\n>(opts?: {\n  select?: (matches: TRouteMatch[]) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  return useRouterState({\n    select: (state) => {\n      const matches = getRenderedMatches(state)\n      return opts?.select\n        ? opts.select(matches as TRouteMatch[])\n        : (matches as T)\n    },\n  })\n}\n\nexport function useParentMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = TRouteMatch[],\n>(opts?: {\n  select?: (matches: TRouteMatch[]) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId),\n      )\n      return opts?.select\n        ? opts.select(matches as TRouteMatch[])\n        : (matches as T)\n    },\n  })\n}\n\nexport function useChildMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = RouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = TRouteMatch[],\n>(opts?: {\n  select?: (matches: TRouteMatch[]) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1,\n      )\n      return opts?.select\n        ? opts.select(matches as TRouteMatch[])\n        : (matches as T)\n    },\n  })\n}\n\nexport function useLoaderDeps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderDeps'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderDeps)\n        : s?.loaderDeps\n    },\n  })\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderData'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderData)\n        : s?.loaderData\n    },\n  })\n}\n\nexport function isServerSideError(error: unknown): error is {\n  __isServerError: true\n  data: Record<string, any>\n} {\n  if (!(typeof error === 'object' && error && 'data' in error)) return false\n  if (!('__isServerError' in error && error.__isServerError)) return false\n  if (!(typeof error.data === 'object' && error.data)) return false\n\n  return error.__isServerError === true\n}\n\nexport function defaultDeserializeError(serializedData: Record<string, any>) {\n  if ('name' in serializedData && 'message' in serializedData) {\n    const error = new Error(serializedData.message)\n    error.name = serializedData.name\n    return error\n  }\n\n  return serializedData.data\n}\n"],"names":["React","useRouter","useRouterState","jsx","CatchBoundary","ErrorComponent","Fragment","_a","route","CatchNotFound","isNotFound","pick","rootRouteId","DefaultGlobalNotFound","Outlet"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCa,MAAA,eAAeA,iBAAM,cAAkC,MAAS;AAiDtE,SAAS,UAAU;AACxB,QAAM,SAASC,UAAAA;AACf,QAAM,UAAUC,eAAAA,eAAe;AAAA,IAC7B,QAAQ,CAAC,MAAM;;AACb,cAAO,wBAAmB,CAAC,EAAE,CAAC,MAAvB,mBAA0B;AAAA,IACnC;AAAA,EAAA,CACD;AAED,SACGC,2BAAAA,IAAA,aAAa,UAAb,EAAsB,OAAO,SAC5B,UAAAA,2BAAA;AAAA,IAACC,cAAA;AAAA,IAAA;AAAA,MACC,aAAa,MAAA;;AAAM,4BAAO,MAAM,iBAAiB,UAA9B,mBAAqC;AAAA;AAAA,MACxD,gBAAgBC,cAAA;AAAA,MAChB,SAAS,CAAC,UAAU;AAClB;AAAA,UACE;AAAA,UACA;AAAA,QAAA;AAEF,gBAAQ,MAAM,KAAK;AAAA,MACrB;AAAA,MAEC,UAAU,UAAAF,2BAAA,IAAC,OAAM,EAAA,QAAkB,CAAA,IAAK;AAAA,IAAA;AAAA,EAE7C,EAAA,CAAA;AAEJ;AAEA,SAAS,aAAa,OAAY;AACzB,SAAAA,2BAAAA,IAAAG,WAAAA,UAAA,EAAG,gBAAM,SAAS,CAAA;AAC3B;AAEgB,SAAA,MAAM,EAAE,WAAgC;;AACtD,QAAM,SAASL,UAAAA;AACf,QAAM,UAAUC,eAAAA,eAAe;AAAA,IAC7B,QAAQ,CAAC;;AACP,cAAAK,MAAA,mBAAmB,CAAC,EAAE,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO,MAAlD,gBAAAA,IAAqD;AAAA;AAAA,EAAA,CACxD;AAED;AAAA,IACE;AAAA,IACA,uCAAuC,OAAO;AAAA,EAAA;AAG1C,QAAAC,SAAQ,OAAO,WAAW,OAAO;AAEvC,QAAM,mBAAoBA,OAAM,QAAQ,oBACtC,OAAO,QAAQ;AAEjB,QAAM,iBAAiB,mBAAoBL,2BAAAA,IAAA,kBAAA,CAAA,CAAiB,IAAK;AAEjE,QAAM,sBACJK,OAAM,QAAQ,kBACd,OAAO,QAAQ,yBACfH;AAEF,QAAM,yBAAyBG,OAAM;AAAA;AAAA,IAEjCA,OAAM,QAAQ,uBACd,YAAO,QAAQ,kBAAf,mBAA8B,QAAQ;AAAA,MACtCA,OAAM,QAAQ;AAElB,QAAM,2BACJA,OAAM,QAAQ,kBACd,sBACA,KAAAA,OAAM,QAAQ,cAAd,mBAAyB,cACzB,KAAAA,OAAM,QAAQ,qBAAd,mBAAgC,cAC/B,KAAAA,OAAM,QAAQ,mBAAd,mBAAsC,WACnCR,iBAAM,WACN;AAEA,QAAA,wBAAwB,sBAC1BI,cACA,gBAAA;AAEE,QAAA,2BAA2B,yBAC7BK,SACA,gBAAA;AAGF,SAAAN,2BAAA,IAAC,aAAa,UAAb,EAAsB,OAAO,SAC5B,UAAAA,2BAAAA,IAAC,0BAAyB,EAAA,UAAU,gBAClC,UAAAA,2BAAA;AAAA,IAAC;AAAA,IAAA;AAAA,MACC,aAAa,MAAA;;AAAM,gBAAAI,MAAA,OAAO,MAAM,iBAAiB,UAA9B,gBAAAA,IAAqC;AAAA;AAAA,MACxD,gBAAgB;AAAA,MAChB,SAAS,CAAC,UAAU;AAElB,YAAIG,SAAAA,WAAW,KAAK;AAAS,gBAAA;AACrB,gBAAA,OAAO,yBAAyB,OAAO,EAAE;AACjD,gBAAQ,MAAM,KAAK;AAAA,MACrB;AAAA,MAEA,UAAAP,2BAAA;AAAA,QAAC;AAAA,QAAA;AAAA,UACC,UAAU,CAAC,UAAU;AAEnB,gBAAI,CAAC,0BAA2B,MAAM,UAAU,CAACK,OAAM;AAC/C,oBAAA;AAED,mBAAAR,iBAAM,cAAc,wBAAwB;AAAA,cACjD,MAAM,MAAM;AAAA,YAAA,CACb;AAAA,UACH;AAAA,UAEA,UAAAG,2BAAAA,IAAC,YAAW,EAAA,SAAmB,eAAgC,CAAA;AAAA,QAAA;AAAA,MACjE;AAAA,IAAA;AAAA,EAAA,EAEJ,CAAA,EACF,CAAA;AAEJ;AAEA,SAAS,WAAW;AAAA,EAClB;AAAA,EACA;AACF,GAGQ;;AACN,QAAM,SAASF,UAAAA;AACf,QAAM,UAAUC,eAAAA,eAAe;AAAA,IAC7B,QAAQ,CAAC;;AACP,cAAAK,MAAA,mBAAmB,CAAC,EAAE,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO,MAAlD,gBAAAA,IAAqD;AAAA;AAAA,EAAA,CACxD;AAEK,QAAAC,UAAQ,OAAO,WAAW,OAAO;AAEvC,QAAM,QAAQN,eAAAA,eAAe;AAAA,IAC3B,QAAQ,CAAC,MACPS,MAAA,KAAK,mBAAmB,CAAC,EAAE,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO,GAAI;AAAA,MACzD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAAA,EAAA,CACJ;AAGD,MAAI,MAAM,eAAe;AACvB,QAAI,YAAYC,MAAA,eAAe,CAACJ,QAAM,QAAQ;AAC5C,4CAAQK,gCAAsB,CAAA,CAAA;AAEhC;AAAA,MACEL,QAAM,QAAQ;AAAA,MACd;AAAA,IAAA;AAGF,0CAAQA,QAAM,QAAQ,mBAAd,EAAgC,MAAM,MAAM,cAAe,CAAA;AAAA,EACrE;AAEI,MAAA,MAAM,WAAW,SAAS;AACxB,QAAA,kBAAkB,MAAM,KAAK,GAAG;AAClC,YAAM,qBACJ,YAAO,QAAQ,oBAAf,mBAAgC,gBAAe;AAC3C,YAAA,iBAAiB,MAAM,MAAM,IAAI;AAAA,IAAA,OAClC;AACL,YAAM,MAAM;AAAA,IACd;AAAA,EACF;AAEI,MAAA,MAAM,WAAW,WAAW;AAC9B,QAAI,MAAM,aAAa;AACd,aAAA;AAAA,IACT;AACA,UAAM,MAAM;AAAA,EACd;AAEI,MAAA,MAAM,WAAW,WAAW;AAC9B,QAAI,OAAOA,QAAM,QAAQ,aAAa,OAAO,QAAQ;AAErD,QAAI,MAAM;AACR,4CAAQ,MAAK,CAAA,CAAA;AAAA,IACf;AAEA,0CAAQ,QAAO,CAAA,CAAA;AAAA,EACjB;AAEA;AAAA,IACE;AAAA,IACA;AAAA,EAAA;AAEJ;AAEO,MAAM,SAASR,iBAAM,KAAK,SAASc,UAAS;AAC3C,QAAA,UAAUd,iBAAM,WAAW,YAAY;AAE7C,QAAM,eAAeE,eAAAA,eAAe;AAAA,IAClC,QAAQ,CAAC,MAAM;;AACP,YAAA,UAAU,mBAAmB,CAAC;AACpC,YAAM,QAAQ,QAAQ,UAAU,CAAC,MAAM,EAAE,OAAO,OAAO;AAChD,cAAA,aAAQ,QAAQ,CAAC,MAAjB,mBAAoB;AAAA,IAC7B;AAAA,EAAA,CACD;AAED,MAAI,CAAC,cAAc;AACV,WAAA;AAAA,EACT;AAEO,SAAAC,2BAAA,IAAC,OAAM,EAAA,SAAS,aAAc,CAAA;AACvC,CAAC;AA0BM,SAAS,gBAEZ;AACaD,gCAAA,EAAE,QAAQ,CAAC,MAAM,CAAC,EAAE,UAAU,EAAE,gBAAgB,EAAA,CAAG;AAC5D,QAAA,EAAE,eAAeD,UAAAA;AAEvB,SAAOD,iBAAM;AAAA,IACX,CAOE,SACmE;AACnE,YAAM,EAAE,SAAS,eAAe,OAAO,eAAe,GAAG,KAAS,IAAA;AAElE,aAAO,WAAW,MAAa;AAAA,QAC7B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA,CACD;AAAA,IACH;AAAA,IACA,CAAC;AAAA,EAAA;AAEL;AAoBO,SAAS,WAOd,OACK;AACL,QAAM,aAAa;AACb,QAAA,SAAS,WAAW,KAAY;AAElC,MAAA,OAAO,MAAM,aAAa,YAAY;AAChC,WAAA,MAAM,SAAiB,MAAM;AAAA,EACvC;AAEA,SAAO,CAAC,CAAC,SAAS,MAAM,WAAW;AACrC;AAEO,SAAS,mBAEd,OAAgC;;AACzB,WAAA,WAAM,mBAAN,mBAAsB,KAAK,CAAC,MAAM,EAAE,gBACvC,MAAM,iBACN,MAAM;AACZ;AAEO,SAAS,SAOd,MAGW;;AACX,QAAM,SAASC,UAAAA;AACT,QAAA,iBAAiBD,iBAAM,WAAW,YAAY;AAEpD,QAAM,uBAAsB,wBAAmB,OAAO,KAAK,EAAE;AAAA,IAC3D,CAAC,MAAM,EAAE,OAAO;AAAA,EACf,MAFyB,mBAEzB;AAEH,QAAM,gBAAgB,MAAM;AACpB,UAAA,UAAU,mBAAmB,OAAO,KAAK;AAC/C,UAAM,SAAQ,6BAAM,QAChB,QAAQ,KAAK,CAAC,MAAM,EAAE,aAAY,6BAAM,KAAI,IAC5C,QAAQ,KAAK,CAAC,MAAM,EAAE,OAAO,cAAc;AAC/C,WAAO,MAAO;AAAA,EAAA;AAGZ,OAAA,6BAAM,WAAU,MAAM;AACxB;AAAA,MACE,uBAAuB;AAAA,MACvB,aACE,YACF,kEAAkE,mBAAmB,uCACnF,YACF,wCACE,YACF;AAAA,IAAA;AAAA,EAEJ;AAEA,QAAM,iBAAiBE,eAAAA,eAAe;AAAA,IACpC,QAAQ,CAAC,UAAU;AACX,YAAA,QAAQ,mBAAmB,KAAK,EAAE;AAAA,QACtC,CAAC,MAAM,EAAE,OAAO;AAAA,MAAA;AAGlB;AAAA,QACE;AAAA,QACA,mBACE,6BAAM,QACF,yBAAyB,KAAK,IAAI,MAClC,kBACN;AAAA,MAAA;AAGF,cAAO,6BAAM,UAAS,KAAK,OAAO,KAAY,IAAI;AAAA,IACpD;AAAA,EAAA,CACD;AAEM,SAAA;AACT;AAEO,SAAS,WAMd,MAGI;AACJ,SAAOA,8BAAe;AAAA,IACpB,QAAQ,CAAC,UAAU;AACX,YAAA,UAAU,mBAAmB,KAAK;AACxC,cAAO,6BAAM,UACT,KAAK,OAAO,OAAwB,IACnC;AAAA,IACP;AAAA,EAAA,CACD;AACH;AAEO,SAAS,iBAMd,MAGI;AACE,QAAA,iBAAiBF,iBAAM,WAAW,YAAY;AAEpD,SAAO,WAAW;AAAA,IAChB,QAAQ,CAAC,YAAY;AACnB,gBAAU,QAAQ;AAAA,QAChB;AAAA,QACA,QAAQ,UAAU,CAAC,MAAM,EAAE,OAAO,cAAc;AAAA,MAAA;AAElD,cAAO,6BAAM,UACT,KAAK,OAAO,OAAwB,IACnC;AAAA,IACP;AAAA,EAAA,CACD;AACH;AAEO,SAAS,gBAMd,MAGI;AACE,QAAA,iBAAiBA,iBAAM,WAAW,YAAY;AAEpD,SAAO,WAAW;AAAA,IAChB,QAAQ,CAAC,YAAY;AACnB,gBAAU,QAAQ;AAAA,QAChB,QAAQ,UAAU,CAAC,MAAM,EAAE,OAAO,cAAc,IAAI;AAAA,MAAA;AAEtD,cAAO,6BAAM,UACT,KAAK,OAAO,OAAwB,IACnC;AAAA,IACP;AAAA,EAAA,CACD;AACH;AAEO,SAAS,cASd,MAGW;AACX,SAAO,SAAS;AAAA,IACd,GAAG;AAAA,IACH,QAAQ,CAAC,MAAM;AACN,aAAA,OAAO,KAAK,WAAW,aAC1B,KAAK,OAAO,uBAAG,UAAU,IACzB,uBAAG;AAAA,IACT;AAAA,EAAA,CACD;AACH;AAEO,SAAS,cASd,MAGW;AACX,SAAO,SAAS;AAAA,IACd,GAAG;AAAA,IACH,QAAQ,CAAC,MAAM;AACN,aAAA,OAAO,KAAK,WAAW,aAC1B,KAAK,OAAO,uBAAG,UAAU,IACzB,uBAAG;AAAA,IACT;AAAA,EAAA,CACD;AACH;AAEO,SAAS,kBAAkB,OAGhC;AACA,MAAI,EAAE,OAAO,UAAU,YAAY,SAAS,UAAU;AAAe,WAAA;AACjE,MAAA,EAAE,qBAAqB,SAAS,MAAM;AAAyB,WAAA;AACnE,MAAI,EAAE,OAAO,MAAM,SAAS,YAAY,MAAM;AAAc,WAAA;AAE5D,SAAO,MAAM,oBAAoB;AACnC;AAEO,SAAS,wBAAwB,gBAAqC;AACvE,MAAA,UAAU,kBAAkB,aAAa,gBAAgB;AAC3D,UAAM,QAAQ,IAAI,MAAM,eAAe,OAAO;AAC9C,UAAM,OAAO,eAAe;AACrB,WAAA;AAAA,EACT;AAEA,SAAO,eAAe;AACxB;;;;;;;;;;;;;;;;"}