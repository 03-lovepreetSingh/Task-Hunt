import { createBrowserHistory, createMemoryHistory } from "@tanstack/history";
import { Store } from "@tanstack/react-store";
import { rootRouteId } from "./route.js";
import { defaultStringifySearch, defaultParseSearch } from "./searchParams.js";
import { replaceEqualDeep, pick, deepEqual, escapeJSON, last, functionalUpdate } from "./utils.js";
import { getRouteMatch } from "./RouterProvider.js";
import { trimPath, trimPathLeft, parsePathname, resolvePath, cleanPath, matchPathname, trimPathRight, interpolatePath, joinPaths } from "./path.js";
import invariant from "tiny-invariant";
import { isRedirect } from "./redirects.js";
import { isNotFound } from "./not-found.js";
import warning from "tiny-warning";
const componentTypes = [
  "component",
  "errorComponent",
  "pendingComponent",
  "notFoundComponent"
];
function createRouter(options) {
  return new Router(options);
}
class Router {
  /**
   * @deprecated Use the `createRouter` function instead
   */
  constructor(options) {
    this.tempLocationKey = `${Math.round(
      Math.random() * 1e7
    )}`;
    this.resetNextScroll = true;
    this.navigateTimeout = null;
    this.latestLoadPromise = Promise.resolve();
    this.subscribers = /* @__PURE__ */ new Set();
    this.injectedHtml = [];
    this.startReactTransition = (fn) => fn();
    this.update = (newOptions) => {
      if (newOptions.notFoundRoute) {
        console.warn(
          "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info."
        );
      }
      const previousOptions = this.options;
      this.options = {
        ...this.options,
        ...newOptions
      };
      if (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) {
        if (newOptions.basepath === void 0 || newOptions.basepath === "" || newOptions.basepath === "/") {
          this.basepath = "/";
        } else {
          this.basepath = `/${trimPath(newOptions.basepath)}`;
        }
      }
      if (!this.history || this.options.history && this.options.history !== this.history) {
        this.history = this.options.history ?? (typeof document !== "undefined" ? createBrowserHistory() : createMemoryHistory({
          initialEntries: [this.options.basepath || "/"]
        }));
        this.latestLocation = this.parseLocation();
      }
      if (this.options.routeTree !== this.routeTree) {
        this.routeTree = this.options.routeTree;
        this.buildRouteTree();
      }
      if (!this.__store) {
        this.__store = new Store(getInitialRouterState(this.latestLocation), {
          onUpdate: () => {
            this.__store.state = {
              ...this.state,
              status: this.state.isTransitioning || this.state.isLoading ? "pending" : "idle"
            };
          }
        });
      }
    };
    this.buildRouteTree = () => {
      this.routesById = {};
      this.routesByPath = {};
      const notFoundRoute = this.options.notFoundRoute;
      if (notFoundRoute) {
        notFoundRoute.init({ originalIndex: 99999999999 });
        this.routesById[notFoundRoute.id] = notFoundRoute;
      }
      const recurseRoutes = (childRoutes) => {
        childRoutes.forEach((childRoute, i) => {
          childRoute.init({ originalIndex: i });
          const existingRoute = this.routesById[childRoute.id];
          invariant(
            !existingRoute,
            `Duplicate routes found with id: ${String(childRoute.id)}`
          );
          this.routesById[childRoute.id] = childRoute;
          if (!childRoute.isRoot && childRoute.path) {
            const trimmedFullPath = trimPathRight(childRoute.fullPath);
            if (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) {
              this.routesByPath[trimmedFullPath] = childRoute;
            }
          }
          const children = childRoute.children;
          if (children == null ? void 0 : children.length) {
            recurseRoutes(children);
          }
        });
      };
      recurseRoutes([this.routeTree]);
      const scoredRoutes = [];
      Object.values(this.routesById).forEach((d, i) => {
        var _a;
        if (d.isRoot || !d.path) {
          return;
        }
        const trimmed = trimPathLeft(d.fullPath);
        const parsed = parsePathname(trimmed);
        while (parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === "/") {
          parsed.shift();
        }
        const scores = parsed.map((d2) => {
          if (d2.value === "/") {
            return 0.75;
          }
          if (d2.type === "param") {
            return 0.5;
          }
          if (d2.type === "wildcard") {
            return 0.25;
          }
          return 1;
        });
        scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores });
      });
      this.flatRoutes = scoredRoutes.sort((a, b) => {
        const minLength = Math.min(a.scores.length, b.scores.length);
        for (let i = 0; i < minLength; i++) {
          if (a.scores[i] !== b.scores[i]) {
            return b.scores[i] - a.scores[i];
          }
        }
        if (a.scores.length !== b.scores.length) {
          return b.scores.length - a.scores.length;
        }
        for (let i = 0; i < minLength; i++) {
          if (a.parsed[i].value !== b.parsed[i].value) {
            return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
          }
        }
        return a.index - b.index;
      }).map((d, i) => {
        d.child.rank = i;
        return d.child;
      });
    };
    this.subscribe = (eventType, fn) => {
      const listener = {
        eventType,
        fn
      };
      this.subscribers.add(listener);
      return () => {
        this.subscribers.delete(listener);
      };
    };
    this.emit = (routerEvent) => {
      this.subscribers.forEach((listener) => {
        if (listener.eventType === routerEvent.type) {
          listener.fn(routerEvent);
        }
      });
    };
    this.checkLatest = (promise) => {
      return this.latestLoadPromise !== promise ? this.latestLoadPromise : void 0;
    };
    this.parseLocation = (previousLocation) => {
      const parse = ({
        pathname,
        search,
        hash,
        state
      }) => {
        const parsedSearch = this.options.parseSearch(search);
        const searchStr = this.options.stringifySearch(parsedSearch);
        return {
          pathname,
          searchStr,
          search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
          hash: hash.split("#").reverse()[0] ?? "",
          href: `${pathname}${searchStr}${hash}`,
          state: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.state, state)
        };
      };
      const location = parse(this.history.location);
      let { __tempLocation, __tempKey } = location.state;
      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
        const parsedTempLocation = parse(__tempLocation);
        parsedTempLocation.state.key = location.state.key;
        delete parsedTempLocation.state.__tempLocation;
        return {
          ...parsedTempLocation,
          maskedLocation: location
        };
      }
      return location;
    };
    this.resolvePathWithBase = (from, path) => {
      return resolvePath(this.basepath, from, cleanPath(path));
    };
    this.matchRoutes = (pathname, locationSearch, opts) => {
      let routeParams = {};
      let foundRoute = this.flatRoutes.find((route) => {
        const matchedParams = matchPathname(
          this.basepath,
          trimPathRight(pathname),
          {
            to: route.fullPath,
            caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,
            fuzzy: true
          }
        );
        if (matchedParams) {
          routeParams = matchedParams;
          return true;
        }
        return false;
      });
      let routeCursor = foundRoute || this.routesById["__root__"];
      let matchedRoutes = [routeCursor];
      let isGlobalNotFound = false;
      if (
        // If we found a route, and it's not an index route and we have left over path
        foundRoute ? foundRoute.path !== "/" && routeParams["**"] : (
          // Or if we didn't find a route and we have left over path
          trimPathRight(pathname)
        )
      ) {
        if (this.options.notFoundRoute) {
          matchedRoutes.push(this.options.notFoundRoute);
        } else {
          isGlobalNotFound = true;
        }
      }
      while (routeCursor == null ? void 0 : routeCursor.parentRoute) {
        routeCursor = routeCursor.parentRoute;
        if (routeCursor)
          matchedRoutes.unshift(routeCursor);
      }
      const parseErrors = matchedRoutes.map((route) => {
        let parsedParamsError;
        if (route.options.parseParams) {
          try {
            const parsedParams = route.options.parseParams(routeParams);
            Object.assign(routeParams, parsedParams);
          } catch (err) {
            parsedParamsError = new PathParamError(err.message, {
              cause: err
            });
            if (opts == null ? void 0 : opts.throwOnError) {
              throw parsedParamsError;
            }
            return parsedParamsError;
          }
        }
        return;
      });
      const matches = [];
      matchedRoutes.forEach((route, index) => {
        var _a, _b, _c, _d, _e, _f;
        const parentMatch = matches[index - 1];
        const [preMatchSearch, searchError] = (() => {
          const parentSearch = (parentMatch == null ? void 0 : parentMatch.search) ?? locationSearch;
          try {
            const validator = typeof route.options.validateSearch === "object" ? route.options.validateSearch.parse : route.options.validateSearch;
            let search = (validator == null ? void 0 : validator(parentSearch)) ?? {};
            return [
              {
                ...parentSearch,
                ...search
              },
              void 0
            ];
          } catch (err) {
            const searchError2 = new SearchParamError(err.message, {
              cause: err
            });
            if (opts == null ? void 0 : opts.throwOnError) {
              throw searchError2;
            }
            return [parentSearch, searchError2];
          }
        })();
        const loaderDeps = ((_b = (_a = route.options).loaderDeps) == null ? void 0 : _b.call(_a, {
          search: preMatchSearch
        })) ?? "";
        const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "";
        const interpolatedPath = interpolatePath({
          path: route.fullPath,
          params: routeParams
        });
        const matchId = interpolatePath({
          path: route.id,
          params: routeParams,
          leaveWildcards: true
        }) + loaderDepsHash;
        const existingMatch = getRouteMatch(this.state, matchId);
        const cause = this.state.matches.find((d) => d.id === matchId) ? "stay" : "enter";
        const match = existingMatch ? {
          ...existingMatch,
          cause,
          notFoundError: isGlobalNotFound && route.id === rootRouteId ? { global: true } : void 0,
          params: routeParams
        } : {
          id: matchId,
          routeId: route.id,
          params: routeParams,
          pathname: joinPaths([this.basepath, interpolatedPath]),
          updatedAt: Date.now(),
          search: {},
          searchError: void 0,
          status: "pending",
          showPending: false,
          isFetching: false,
          error: void 0,
          paramsError: parseErrors[index],
          loadPromise: Promise.resolve(),
          routeContext: void 0,
          context: void 0,
          abortController: new AbortController(),
          fetchCount: 0,
          cause,
          loaderDeps,
          invalid: false,
          preload: false,
          notFoundError: isGlobalNotFound && route.id === rootRouteId ? { global: true } : void 0,
          links: (_d = (_c = route.options).links) == null ? void 0 : _d.call(_c),
          scripts: (_f = (_e = route.options).scripts) == null ? void 0 : _f.call(_e),
          staticData: route.options.staticData || {}
        };
        match.search = replaceEqualDeep(match.search, preMatchSearch);
        match.searchError = searchError;
        matches.push(match);
      });
      return matches;
    };
    this.cancelMatch = (id) => {
      var _a, _b;
      (_b = (_a = getRouteMatch(this.state, id)) == null ? void 0 : _a.abortController) == null ? void 0 : _b.abort();
    };
    this.cancelMatches = () => {
      var _a;
      (_a = this.state.pendingMatches) == null ? void 0 : _a.forEach((match) => {
        this.cancelMatch(match.id);
      });
    };
    this.buildLocation = (opts) => {
      const build = (dest = {}, matches) => {
        var _a, _b;
        const relevantMatches = this.state.pendingMatches || this.state.matches;
        const fromSearch = ((_a = relevantMatches[relevantMatches.length - 1]) == null ? void 0 : _a.search) || this.latestLocation.search;
        let pathname = this.resolvePathWithBase(
          dest.from ?? this.latestLocation.pathname,
          `${dest.to ?? ""}`
        );
        const fromMatches = this.matchRoutes(
          this.latestLocation.pathname,
          fromSearch
        );
        const stayingMatches = matches == null ? void 0 : matches.filter(
          (d) => fromMatches == null ? void 0 : fromMatches.find((e) => e.routeId === d.routeId)
        );
        const prevParams = { ...(_b = last(fromMatches)) == null ? void 0 : _b.params };
        let nextParams = (dest.params ?? true) === true ? prevParams : { ...prevParams, ...functionalUpdate(dest.params, prevParams) };
        if (nextParams) {
          matches == null ? void 0 : matches.map((d) => this.looseRoutesById[d.routeId].options.stringifyParams).filter(Boolean).forEach((fn) => {
            nextParams = { ...nextParams, ...fn(nextParams) };
          });
        }
        pathname = interpolatePath({
          path: pathname,
          params: nextParams ?? {},
          leaveWildcards: false,
          leaveParams: opts.leaveParams
        });
        const preSearchFilters = (stayingMatches == null ? void 0 : stayingMatches.map(
          (match) => this.looseRoutesById[match.routeId].options.preSearchFilters ?? []
        ).flat().filter(Boolean)) ?? [];
        const postSearchFilters = (stayingMatches == null ? void 0 : stayingMatches.map(
          (match) => this.looseRoutesById[match.routeId].options.postSearchFilters ?? []
        ).flat().filter(Boolean)) ?? [];
        const preFilteredSearch = (preSearchFilters == null ? void 0 : preSearchFilters.length) ? preSearchFilters == null ? void 0 : preSearchFilters.reduce(
          (prev, next) => next(prev),
          fromSearch
        ) : fromSearch;
        const destSearch = dest.search === true ? preFilteredSearch : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} : (preSearchFilters == null ? void 0 : preSearchFilters.length) ? preFilteredSearch : {};
        const postFilteredSearch = (postSearchFilters == null ? void 0 : postSearchFilters.length) ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
        const search = replaceEqualDeep(fromSearch, postFilteredSearch);
        const searchStr = this.options.stringifySearch(search);
        const hash = dest.hash === true ? this.latestLocation.hash : dest.hash ? functionalUpdate(dest.hash, this.latestLocation.hash) : void 0;
        const hashStr = hash ? `#${hash}` : "";
        let nextState = dest.state === true ? this.latestLocation.state : dest.state ? functionalUpdate(dest.state, this.latestLocation.state) : {};
        nextState = replaceEqualDeep(this.latestLocation.state, nextState);
        return {
          pathname,
          search,
          searchStr,
          state: nextState,
          hash: hash ?? "",
          href: `${pathname}${searchStr}${hashStr}`,
          unmaskOnReload: dest.unmaskOnReload
        };
      };
      const buildWithMatches = (dest = {}, maskedDest) => {
        var _a;
        let next = build(dest);
        let maskedNext = maskedDest ? build(maskedDest) : void 0;
        if (!maskedNext) {
          let params = {};
          let foundMask = (_a = this.options.routeMasks) == null ? void 0 : _a.find((d) => {
            const match = matchPathname(this.basepath, next.pathname, {
              to: d.from,
              caseSensitive: false,
              fuzzy: false
            });
            if (match) {
              params = match;
              return true;
            }
            return false;
          });
          if (foundMask) {
            maskedDest = {
              ...pick(opts, ["from"]),
              ...foundMask,
              params
            };
            maskedNext = build(maskedDest);
          }
        }
        const nextMatches = this.matchRoutes(next.pathname, next.search);
        const maskedMatches = maskedNext ? this.matchRoutes(maskedNext.pathname, maskedNext.search) : void 0;
        const maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : void 0;
        const final = build(dest, nextMatches);
        if (maskedFinal) {
          final.maskedLocation = maskedFinal;
        }
        return final;
      };
      if (opts.mask) {
        return buildWithMatches(opts, {
          ...pick(opts, ["from"]),
          ...opts.mask
        });
      }
      return buildWithMatches(opts);
    };
    this.commitLocation = async ({
      startTransition,
      ...next
    }) => {
      if (this.navigateTimeout)
        clearTimeout(this.navigateTimeout);
      const isSameUrl = this.latestLocation.href === next.href;
      if (!isSameUrl || !next.replace) {
        let { maskedLocation, ...nextHistory } = next;
        if (maskedLocation) {
          nextHistory = {
            ...maskedLocation,
            state: {
              ...maskedLocation.state,
              __tempKey: void 0,
              __tempLocation: {
                ...nextHistory,
                search: nextHistory.searchStr,
                state: {
                  ...nextHistory.state,
                  __tempKey: void 0,
                  __tempLocation: void 0,
                  key: void 0
                }
              }
            }
          };
          if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {
            nextHistory.state.__tempKey = this.tempLocationKey;
          }
        }
        const apply = () => {
          this.history[next.replace ? "replace" : "push"](
            nextHistory.href,
            nextHistory.state
          );
        };
        if (startTransition ?? true) {
          this.startReactTransition(apply);
        } else {
          apply();
        }
      }
      this.resetNextScroll = next.resetScroll ?? true;
      return this.latestLoadPromise;
    };
    this.buildAndCommitLocation = ({
      replace,
      resetScroll,
      startTransition,
      ...rest
    } = {}) => {
      const location = this.buildLocation(rest);
      return this.commitLocation({
        ...location,
        startTransition,
        replace,
        resetScroll
      });
    };
    this.navigate = ({ from, to, ...rest }) => {
      const toString = String(to);
      let isExternal;
      try {
        new URL(`${toString}`);
        isExternal = true;
      } catch (e) {
      }
      invariant(
        !isExternal,
        "Attempting to navigate to external url with this.navigate!"
      );
      return this.buildAndCommitLocation({
        ...rest,
        from,
        to
        // to: toString,
      });
    };
    this.loadMatches = async ({
      checkLatest,
      matches,
      preload
    }) => {
      var _a, _b;
      let latestPromise;
      let firstBadMatchIndex;
      const updateMatch = (match) => {
        var _a2;
        const isPending = (_a2 = this.state.pendingMatches) == null ? void 0 : _a2.find(
          (d) => d.id === match.id
        );
        const isMatched = this.state.matches.find((d) => d.id === match.id);
        const matchesKey = isPending ? "pendingMatches" : isMatched ? "matches" : "cachedMatches";
        this.__store.setState((s) => {
          var _a3;
          return {
            ...s,
            [matchesKey]: (_a3 = s[matchesKey]) == null ? void 0 : _a3.map(
              (d) => d.id === match.id ? match : d
            )
          };
        });
      };
      try {
        for (let [index, match] of matches.entries()) {
          const parentMatch = matches[index - 1];
          const route = this.looseRoutesById[match.routeId];
          const abortController = new AbortController();
          const handleErrorAndRedirect = (err, code) => {
            var _a2, _b2;
            err.routerCode = code;
            firstBadMatchIndex = firstBadMatchIndex ?? index;
            if (isRedirect(err)) {
              throw err;
            }
            if (isNotFound(err)) {
              this.updateMatchesWithNotFound(matches, match, err);
            }
            try {
              (_b2 = (_a2 = route.options).onError) == null ? void 0 : _b2.call(_a2, err);
            } catch (errorHandlerErr) {
              err = errorHandlerErr;
              if (isRedirect(errorHandlerErr)) {
                throw errorHandlerErr;
              }
            }
            matches[index] = match = {
              ...match,
              error: err,
              status: "error",
              updatedAt: Date.now(),
              abortController: new AbortController()
            };
          };
          try {
            if (match.paramsError) {
              handleErrorAndRedirect(match.paramsError, "PARSE_PARAMS");
            }
            if (match.searchError) {
              handleErrorAndRedirect(match.searchError, "VALIDATE_SEARCH");
            }
            const parentContext = (parentMatch == null ? void 0 : parentMatch.context) ?? this.options.context ?? {};
            const pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs;
            const pendingPromise = typeof pendingMs === "number" && pendingMs <= 0 ? Promise.resolve() : new Promise((r) => setTimeout(r, pendingMs));
            const beforeLoadContext = await ((_b = (_a = route.options).beforeLoad) == null ? void 0 : _b.call(_a, {
              search: match.search,
              abortController,
              params: match.params,
              preload: !!preload,
              context: parentContext,
              location: this.state.location,
              // TOOD: just expose state and router, etc
              navigate: (opts) => this.navigate({ ...opts, from: match.pathname }),
              buildLocation: this.buildLocation,
              cause: preload ? "preload" : match.cause
            })) ?? {};
            if (isRedirect(beforeLoadContext)) {
              throw beforeLoadContext;
            }
            const context = {
              ...parentContext,
              ...beforeLoadContext
            };
            matches[index] = match = {
              ...match,
              routeContext: replaceEqualDeep(
                match.routeContext,
                beforeLoadContext
              ),
              context: replaceEqualDeep(match.context, context),
              abortController,
              pendingPromise
            };
          } catch (err) {
            handleErrorAndRedirect(err, "BEFORE_LOAD");
            break;
          }
        }
      } catch (err) {
        if (isRedirect(err)) {
          if (!preload)
            this.navigate(err);
          return matches;
        }
        throw err;
      }
      const validResolvedMatches = matches.slice(0, firstBadMatchIndex);
      const matchPromises = [];
      validResolvedMatches.forEach((match, index) => {
        matchPromises.push(
          new Promise(async (resolve) => {
            var _a2;
            const parentMatchPromise = matchPromises[index - 1];
            const route = this.looseRoutesById[match.routeId];
            const handleErrorAndRedirect = (err) => {
              if (isRedirect(err)) {
                if (!preload) {
                  this.navigate(err);
                }
                return true;
              }
              if (isNotFound(err)) {
                if (!preload) {
                  this.updateMatchesWithNotFound(matches, match, err);
                }
                return true;
              }
              return false;
            };
            let loadPromise;
            matches[index] = match = {
              ...match,
              showPending: false
            };
            let didShowPending = false;
            const pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs;
            const pendingMinMs = route.options.pendingMinMs ?? this.options.defaultPendingMinMs;
            const shouldPending = !preload && typeof pendingMs === "number" && (route.options.pendingComponent ?? this.options.defaultPendingComponent);
            const loaderContext = {
              params: match.params,
              deps: match.loaderDeps,
              preload: !!preload,
              parentMatchPromise,
              abortController: match.abortController,
              context: match.context,
              location: this.state.location,
              navigate: (opts) => this.navigate({ ...opts, from: match.pathname }),
              cause: preload ? "preload" : match.cause
            };
            const fetch = async () => {
              var _a3, _b2, _c, _d, _e, _f, _g, _h;
              if (match.isFetching) {
                loadPromise = (_a3 = getRouteMatch(this.state, match.id)) == null ? void 0 : _a3.loadPromise;
              } else {
                if (match.fetchCount && match.status === "success") {
                  resolve();
                }
                matches[index] = match = {
                  ...match,
                  isFetching: true,
                  fetchCount: match.fetchCount + 1
                };
                const lazyPromise = ((_b2 = route.lazyFn) == null ? void 0 : _b2.call(route).then((lazyRoute) => {
                  Object.assign(route.options, lazyRoute.options);
                })) || Promise.resolve();
                const componentsPromise = lazyPromise.then(
                  () => Promise.all(
                    componentTypes.map(async (type) => {
                      const component = route.options[type];
                      if (component == null ? void 0 : component.preload) {
                        await component.preload();
                      }
                    })
                  )
                );
                async function loader() {
                  var _a4, _b3;
                  return await ((_b3 = (_a4 = route.options).loader) == null ? void 0 : _b3.call(_a4, loaderContext));
                }
                const loaderPromise = loader();
                loadPromise = Promise.all([
                  componentsPromise,
                  loaderPromise,
                  lazyPromise
                ]).then((d) => d[1]);
              }
              matches[index] = match = {
                ...match,
                loadPromise
              };
              updateMatch(match);
              try {
                const loaderData = await loadPromise;
                if (latestPromise = checkLatest())
                  return await latestPromise;
                if (isRedirect(loaderData) || isNotFound(loaderData)) {
                  if (handleErrorAndRedirect(loaderData))
                    return;
                }
                if (didShowPending && pendingMinMs) {
                  await new Promise((r) => setTimeout(r, pendingMinMs));
                }
                if (latestPromise = checkLatest())
                  return await latestPromise;
                const [meta, headers] = await Promise.all([
                  (_d = (_c = route.options).meta) == null ? void 0 : _d.call(_c, {
                    loaderData
                  }),
                  (_f = (_e = route.options).headers) == null ? void 0 : _f.call(_e, {
                    loaderData
                  })
                ]);
                matches[index] = match = {
                  ...match,
                  error: void 0,
                  status: "success",
                  isFetching: false,
                  updatedAt: Date.now(),
                  loaderData,
                  loadPromise: void 0,
                  meta,
                  headers
                };
              } catch (error) {
                if (latestPromise = checkLatest())
                  return await latestPromise;
                if (handleErrorAndRedirect(error))
                  return;
                try {
                  (_h = (_g = route.options).onError) == null ? void 0 : _h.call(_g, error);
                } catch (onErrorError) {
                  error = onErrorError;
                  if (handleErrorAndRedirect(onErrorError))
                    return;
                }
                matches[index] = match = {
                  ...match,
                  error,
                  status: "error",
                  isFetching: false
                };
              }
              updateMatch(match);
            };
            const age = Date.now() - match.updatedAt;
            let staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0;
            let shouldReload;
            const shouldReloadOption = route.options.shouldReload;
            shouldReload = typeof shouldReloadOption === "function" ? shouldReloadOption(loaderContext) : shouldReloadOption;
            matches[index] = match = {
              ...match,
              preload: !!preload && !this.state.matches.find((d) => d.id === match.id)
            };
            if (match.status !== "success") {
              if (shouldPending) {
                (_a2 = match.pendingPromise) == null ? void 0 : _a2.then(async () => {
                  if (latestPromise = checkLatest())
                    return latestPromise;
                  didShowPending = true;
                  matches[index] = match = {
                    ...match,
                    showPending: true
                  };
                  updateMatch(match);
                  resolve();
                });
              }
              await fetch();
            } else if (match.invalid || (shouldReload ?? age > staleAge)) {
              fetch();
            }
            resolve();
          })
        );
      });
      await Promise.all(matchPromises);
      return matches;
    };
    this.invalidate = () => {
      const invalidate = (d) => ({
        ...d,
        invalid: true
      });
      this.__store.setState((s) => {
        var _a;
        return {
          ...s,
          matches: s.matches.map(invalidate),
          cachedMatches: s.cachedMatches.map(invalidate),
          pendingMatches: (_a = s.pendingMatches) == null ? void 0 : _a.map(invalidate)
        };
      });
      this.load();
    };
    this.load = async () => {
      const promise = new Promise(async (resolve, reject) => {
        const next = this.latestLocation;
        const prevLocation = this.state.resolvedLocation;
        const pathDidChange = prevLocation.href !== next.href;
        let latestPromise;
        this.cancelMatches();
        this.emit({
          type: "onBeforeLoad",
          fromLocation: prevLocation,
          toLocation: next,
          pathChanged: pathDidChange
        });
        let pendingMatches;
        const previousMatches = this.state.matches;
        this.__store.batch(() => {
          this.cleanCache();
          pendingMatches = this.matchRoutes(next.pathname, next.search, {
            debug: true
          });
          this.__store.setState((s) => ({
            ...s,
            isLoading: true,
            location: next,
            pendingMatches,
            cachedMatches: s.cachedMatches.filter((d) => {
              return !pendingMatches.find((e) => e.id === d.id);
            })
          }));
        });
        try {
          try {
            await this.loadMatches({
              matches: pendingMatches,
              checkLatest: () => this.checkLatest(promise)
            });
          } catch (err) {
          }
          if (latestPromise = this.checkLatest(promise)) {
            return latestPromise;
          }
          const exitingMatches = previousMatches.filter(
            (match) => !pendingMatches.find((d) => d.id === match.id)
          );
          const enteringMatches = pendingMatches.filter(
            (match) => !previousMatches.find((d) => d.id === match.id)
          );
          const stayingMatches = previousMatches.filter(
            (match) => pendingMatches.find((d) => d.id === match.id)
          );
          this.__store.batch(() => {
            this.__store.setState((s) => ({
              ...s,
              isLoading: false,
              matches: s.pendingMatches,
              pendingMatches: void 0,
              cachedMatches: [
                ...s.cachedMatches,
                ...exitingMatches.filter((d) => d.status !== "error")
              ]
            }));
            this.cleanCache();
          });
          [
            [exitingMatches, "onLeave"],
            [enteringMatches, "onEnter"],
            [stayingMatches, "onStay"]
          ].forEach(([matches, hook]) => {
            matches.forEach((match) => {
              var _a, _b;
              (_b = (_a = this.looseRoutesById[match.routeId].options)[hook]) == null ? void 0 : _b.call(_a, match);
            });
          });
          this.emit({
            type: "onLoad",
            fromLocation: prevLocation,
            toLocation: next,
            pathChanged: pathDidChange
          });
          resolve();
        } catch (err) {
          if (latestPromise = this.checkLatest(promise)) {
            return latestPromise;
          }
          reject(err);
        }
      });
      this.latestLoadPromise = promise;
      return this.latestLoadPromise;
    };
    this.cleanCache = () => {
      this.__store.setState((s) => {
        return {
          ...s,
          cachedMatches: s.cachedMatches.filter((d) => {
            const route = this.looseRoutesById[d.routeId];
            if (!route.options.loader) {
              return false;
            }
            const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;
            return d.status !== "error" && Date.now() - d.updatedAt < gcTime;
          })
        };
      });
    };
    this.preloadRoute = async (navigateOpts = this.state.location) => {
      var _a;
      let next = this.buildLocation(navigateOpts);
      let matches = this.matchRoutes(next.pathname, next.search, {
        throwOnError: true
      });
      const loadedMatchIds = Object.fromEntries(
        (_a = [
          ...this.state.matches,
          ...this.state.pendingMatches ?? [],
          ...this.state.cachedMatches
        ]) == null ? void 0 : _a.map((d) => [d.id, true])
      );
      this.__store.batch(() => {
        matches.forEach((match) => {
          if (!loadedMatchIds[match.id]) {
            this.__store.setState((s) => ({
              ...s,
              cachedMatches: [...s.cachedMatches, match]
            }));
          }
        });
      });
      matches = await this.loadMatches({
        matches,
        preload: true,
        checkLatest: () => void 0
      });
      return matches;
    };
    this.matchRoute = (location, opts) => {
      const matchLocation = {
        ...location,
        to: location.to ? this.resolvePathWithBase(location.from || "", location.to) : void 0,
        params: location.params || {},
        leaveParams: true
      };
      const next = this.buildLocation(matchLocation);
      if ((opts == null ? void 0 : opts.pending) && this.state.status !== "pending") {
        return false;
      }
      const baseLocation = (opts == null ? void 0 : opts.pending) ? this.latestLocation : this.state.resolvedLocation;
      if (!baseLocation) {
        return false;
      }
      const match = matchPathname(this.basepath, baseLocation.pathname, {
        ...opts,
        to: next.pathname
      });
      if (!match) {
        return false;
      }
      if (location.params) {
        if (!deepEqual(match, location.params, true)) {
          return false;
        }
      }
      if (match && ((opts == null ? void 0 : opts.includeSearch) ?? true)) {
        return deepEqual(baseLocation.search, next.search, true) ? match : false;
      }
      return match;
    };
    this.injectHtml = async (html) => {
      this.injectedHtml.push(html);
    };
    this.registeredDeferredsIds = /* @__PURE__ */ new Map();
    this.registeredDeferreds = /* @__PURE__ */ new WeakMap();
    this.getDeferred = (uid) => {
      const token = this.registeredDeferredsIds.get(uid);
      if (!token) {
        return void 0;
      }
      return this.registeredDeferreds.get(token);
    };
    this.dehydrateData = (key, getData) => {
      warning(
        false,
        `The dehydrateData method is deprecated. Please use the injectHtml method to inject your own data.`
      );
      if (typeof document === "undefined") {
        const strKey = typeof key === "string" ? key : JSON.stringify(key);
        this.injectHtml(async () => {
          const id = `__TSR_DEHYDRATED__${strKey}`;
          const data = typeof getData === "function" ? await getData() : getData;
          return `<script id='${id}' suppressHydrationWarning>
  window["__TSR_DEHYDRATED__${escapeJSON(
            strKey
          )}"] = ${JSON.stringify(this.options.transformer.stringify(data))}
<\/script>`;
        });
        return () => this.hydrateData(key);
      }
      return () => void 0;
    };
    this.hydrateData = (key) => {
      warning(
        false,
        `The hydrateData method is deprecated. Please use the extractHtml method to extract your own data.`
      );
      if (typeof document !== "undefined") {
        const strKey = typeof key === "string" ? key : JSON.stringify(key);
        return this.options.transformer.parse(
          window[`__TSR_DEHYDRATED__${strKey}`]
        );
      }
      return void 0;
    };
    this.dehydrate = () => {
      var _a;
      const pickError = ((_a = this.options.errorSerializer) == null ? void 0 : _a.serialize) ?? defaultSerializeError;
      return {
        state: {
          dehydratedMatches: this.state.matches.map((d) => ({
            ...pick(d, [
              "id",
              "status",
              "updatedAt",
              "loaderData",
              // Not-founds that occur during SSR don't require the client to load data before
              // triggering in order to prevent the flicker of the loading component
              "notFoundError"
            ]),
            // If an error occurs server-side during SSRing,
            // send a small subset of the error to the client
            error: d.error ? {
              data: pickError(d.error),
              __isServerError: true
            } : void 0
          }))
        }
      };
    };
    this.hydrate = async (__do_not_use_server_ctx) => {
      var _a, _b, _c;
      let _ctx = __do_not_use_server_ctx;
      if (typeof document !== "undefined") {
        _ctx = (_a = window.__TSR_DEHYDRATED__) == null ? void 0 : _a.data;
      }
      invariant(
        _ctx,
        "Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?"
      );
      const ctx = this.options.transformer.parse(_ctx);
      this.dehydratedData = ctx.payload;
      (_c = (_b = this.options).hydrate) == null ? void 0 : _c.call(_b, ctx.payload);
      const dehydratedState = ctx.router.state;
      let matches = this.matchRoutes(
        this.state.location.pathname,
        this.state.location.search
      ).map((match) => {
        var _a2, _b2, _c2, _d, _e, _f;
        const dehydratedMatch = dehydratedState.dehydratedMatches.find(
          (d) => d.id === match.id
        );
        invariant(
          dehydratedMatch,
          `Could not find a client-side match for dehydrated match with id: ${match.id}!`
        );
        if (dehydratedMatch) {
          const route = this.looseRoutesById[match.routeId];
          return {
            ...match,
            ...dehydratedMatch,
            meta: (_b2 = (_a2 = route.options).meta) == null ? void 0 : _b2.call(_a2, {
              loaderData: dehydratedMatch.loaderData
            }),
            links: (_d = (_c2 = route.options).links) == null ? void 0 : _d.call(_c2),
            scripts: (_f = (_e = route.options).scripts) == null ? void 0 : _f.call(_e)
          };
        }
        return match;
      });
      this.__store.setState((s) => {
        return {
          ...s,
          matches,
          lastUpdated: Date.now()
        };
      });
    };
    this.updateMatchesWithNotFound = (matches, currentMatch, err) => {
      const matchesByRouteId = Object.fromEntries(
        matches.map((match) => [match.routeId, match])
      );
      if (err.global) {
        matchesByRouteId[rootRouteId].notFoundError = err;
      } else {
        let currentRoute = this.routesById[err.route ?? currentMatch.routeId];
        while (!currentRoute.options.notFoundComponent) {
          currentRoute = currentRoute == null ? void 0 : currentRoute.parentRoute;
          invariant(
            currentRoute,
            "Found invalid route tree while trying to find not-found handler."
          );
          if (currentRoute.id === rootRouteId)
            break;
        }
        const match = matchesByRouteId[currentRoute.id];
        invariant(match, "Could not find match for route: " + currentRoute.id);
        match.notFoundError = err;
      }
    };
    this.hasNotFoundMatch = () => {
      return this.__store.state.matches.some((d) => d.notFoundError);
    };
    this.update({
      defaultPreloadDelay: 50,
      defaultPendingMs: 1e3,
      defaultPendingMinMs: 500,
      context: void 0,
      ...options,
      stringifySearch: (options == null ? void 0 : options.stringifySearch) ?? defaultStringifySearch,
      parseSearch: (options == null ? void 0 : options.parseSearch) ?? defaultParseSearch,
      transformer: (options == null ? void 0 : options.transformer) ?? JSON
    });
    if (typeof document !== "undefined") {
      window.__TSR__ROUTER__ = this;
    }
  }
  get state() {
    return this.__store.state;
  }
  get looseRoutesById() {
    return this.routesById;
  }
  // resolveMatchPromise = (matchId: string, key: string, value: any) => {
  //   state.matches
  //     .find((d) => d.id === matchId)
  //     ?.__promisesByKey[key]?.resolve(value)
  // }
}
function lazyFn(fn, key) {
  return async (...args) => {
    const imported = await fn();
    return imported[key || "default"](...args);
  };
}
class SearchParamError extends Error {
}
class PathParamError extends Error {
}
function getInitialRouterState(location) {
  return {
    isLoading: false,
    isTransitioning: false,
    status: "idle",
    resolvedLocation: { ...location },
    location,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    lastUpdated: 0
  };
}
function defaultSerializeError(err) {
  if (err instanceof Error)
    return {
      name: err.name,
      message: err.message
    };
  return {
    data: err
  };
}
export {
  PathParamError,
  Router,
  SearchParamError,
  componentTypes,
  createRouter,
  defaultSerializeError,
  getInitialRouterState,
  lazyFn
};
//# sourceMappingURL=router.js.map
